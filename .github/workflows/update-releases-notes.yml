name: Update Release Notes from PR

on:
  push:
    tags:
      - "v*"

permissions:
  contents: write
  pull-requests: read

jobs:
  update-release-notes:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install gh cli and jq
        run: |
          sudo apt-get update
          sudo apt-get install -y gh jq

      - name: Find latest merged release PR
        id: find_pr
        env:
          GH_TOKEN: ${{ secrets.RELEASE_PLEASE_TOKEN }}
        run: |
          PR_NUMBER=$(gh pr list --state merged --label "autorelease: tagged" --json number,mergedAt,headRefName --jq '[.[] | select(.headRefName | test("^release-please--branches--main"))] | sort_by(.mergedAt) | last.number')
          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT

      - name: Get PR body and format for all packages
        id: get_lists
        env:
          GH_TOKEN: ${{ secrets.RELEASE_PLEASE_TOKEN }}
        run: |
          set -e
          PR_NUMBER="${{ steps.find_pr.outputs.pr_number }}"
          PR_BODY=$(gh pr view "$PR_NUMBER" --json body -q .body)

          echo "$PR_BODY" > pr_body.md
          echo "[DEBUG] --- pr_body.md ---"
          cat pr_body.md
          echo "[DEBUG] --- end pr_body.md ---"

          # 1. Extract the first version header with date and link
          VERSION_HEADER=$(grep -m1 -E '^\[[0-9]+\.[0-9]+\.[0-9]+\]\(.*\) \([0-9]{4}-[0-9]{2}-[0-9]{2}\)$' pr_body.md || true)
          [ -z "$VERSION_HEADER" ] && VERSION_HEADER="## Release"

          echo "[DEBUG] VERSION_HEADER: $VERSION_HEADER"

          # 2. Use awk to split into package blocks (by version header, exclude the header line itself)
          rm -f block*.md || true
          awk '
            BEGIN {blocknum=0;}
            /^\[[0-9]+\.[0-9]+\.[0-9]+\]\(.*\) \([0-9]{4}-[0-9]{2}-[0-9]{2}\}$/ {blocknum++; next}
            blocknum>0 {print > ("block" blocknum ".md")}
          ' pr_body.md

          echo "[DEBUG] block files:"
          ls -l block*.md || echo "No blocks found"

          rm -f lists.md || true

          shopt -s nullglob
          for f in block*.md; do
            if [ ! -s "$f" ]; then
              echo "[DEBUG] Skipping empty $f"
              continue
            fi
            echo "[DEBUG] Processing $f:"
            cat "$f"
            # Try to extract package name from first bolded entry in a list item
            PKG=$(grep -m1 -oP '^\s*[*-]\s+\*\*\K[^*:]+' "$f" | sed 's/_/ /g' || true)
            [ -z "$PKG" ] && PKG="unknown package"
            echo "[DEBUG] PKG: $PKG"
            echo "" >> lists.md
            echo "> $PKG" >> lists.md
            cat "$f" >> lists.md
            echo "" >> lists.md
          done
          shopt -u nullglob

          if [ ! -f lists.md ]; then
            echo "[DEBUG] No lists.md generated; exiting early"
            echo "$VERSION_HEADER" > release_note.md
          else
            {
              echo "$VERSION_HEADER"
              echo "---"
              cat lists.md
            } > release_note.md
          fi

          echo "[DEBUG] ====== Final release note ======"
          cat release_note.md

          echo "release_note<<EOF" >> $GITHUB_OUTPUT
          cat release_note.md >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Update release notes for tag
        env:
          GH_TOKEN: ${{ secrets.RELEASE_PLEASE_TOKEN }}
        run: |
          gh release edit "${GITHUB_REF#refs/tags/}" --notes "${{ steps.get_lists.outputs.release_note }}"
