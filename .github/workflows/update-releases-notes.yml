name: Update Release Notes

on:
  push:
    tags:
      - "v[0-9]+.[0-9]+.[0-9]+"

jobs:
  parse-release-notes:
    runs-on: ubuntu-latest
    permissions:
      contents: write # Needed for gh release edit

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Fetch latest merged release PR body
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          PR_NUMBER=$(gh pr list --state merged --label "autorelease: tagged" --json number,mergedAt,headRefName --jq '[.[] | select(.headRefName | test("^release-please--branches--main"))] | sort_by(.mergedAt) | last.number')
          if [ -z "$PR_NUMBER" ]; then
            echo "No recent release PR found."
            exit 1
          fi
          gh pr view $PR_NUMBER --json body --jq .body > pr_body.md

      - name: Parse release notes and update GitHub release
        env:
          GH_TOKEN: ${{ github.token }}
        shell: bash
        run: |
          set -euo pipefail

          INPUT_FILE="pr_body.md"
          TAG_NAME="${GITHUB_REF##*/}"

          if [[ ! -f "Cargo.toml" ]]; then
            echo "Error: must be run from repo root."
            exit 1
          fi

          # 1. Get all workspace member paths and their [package] names
          declare -A MEMBER_PATH_TO_NAME
          declare -a MEMBER_PATHS

          while IFS= read -r line; do
            member_path="${line%%|*}"
            member_name="${line#*|}"
            rel_path="${member_path#$PWD/}"
            MEMBER_PATH_TO_NAME["$rel_path"]="$member_name"
            MEMBER_PATHS+=("$rel_path")
          done < <(cargo metadata --no-deps --format-version=1 --manifest-path Cargo.toml \
                    | jq -r '.packages[] | select(.source == null) | "\(.manifest_path|sub("/Cargo.toml$";""))|\(.name)"')

          # 2. Extract first version header (with link and date)
          VERSION_HEADER=$(grep -m1 -E '^## \[[0-9]+\.[0-9]+\.[0-9]+\]\(.*\) \([0-9]{4}-[0-9]{2}-[0-9]{2}\)$' "$INPUT_FILE")
          [ -z "$VERSION_HEADER" ] && VERSION_HEADER="## Release"

          # 3. Extract each <details>...</details> block
          awk '/<details>/{f=1;block=""}
               f{block=block $0 "\n"}
               /<\/details>/{f=0; print block; block=""}' "$INPUT_FILE" > details_blocks.txt

          rm -f lists.md
          c=0
          while IFS= read -r -d '' block; do
            c=$((c+1))
            echo "$block" > "block${c}.md"
            CONTEXT=$(grep -m1 -oP '^\s*[*-]\s+\*\*\K[^*:]+' "block${c}.md" | head -1 || true)
            PKG_DISPLAY="$CONTEXT"
            if [ -n "$CONTEXT" ]; then
              echo "DEBUG: Found context '$CONTEXT' in block ${c}"
              for member_path in "${MEMBER_PATHS[@]}"; do
                if find "$member_path" -type f -name "$CONTEXT.*" 2>/dev/null | grep -q .; then
                  PKG_DISPLAY="${MEMBER_PATH_TO_NAME[$member_path]}"
                  echo "DEBUG: Mapped context '$CONTEXT' to package '$PKG_DISPLAY'"
                  break
                fi
              done
            else
              echo "ERROR: No context (scope) found in block ${c}!"
              echo "ERROR: Block content:"
              cat "block${c}.md"
              echo "ERROR: This indicates a commit was made without following Conventional Commits format"
              echo "ERROR: Expected pattern: '* **context**: description' but found none"
              echo "ERROR: Be sure to use Conventional Commits with scope: type(scope): description"
              echo "ERROR: Examples:"
              echo "ERROR:   fix(computed_file): correct documentation"
              echo "ERROR:   feat(signer): add new encryption method"
              echo "ERROR: Valid scopes should match filenames in workspace members"
              exit 1
            fi
            if [ -z "$PKG_DISPLAY" ]; then
              echo "ERROR: Conventional Commit scope '$CONTEXT' could not be mapped to any workspace package!"
              echo "ERROR: Available workspace members and valid scopes:"
              for member_path in "${MEMBER_PATHS[@]}"; do
                echo "  - $member_path -> ${MEMBER_PATH_TO_NAME[$member_path]}"
              done
              echo "ERROR: The scope '$CONTEXT' must match a filename in one of the above directories"
              echo "ERROR: Use: type($CONTEXT): description where $CONTEXT corresponds to a file being modified"
              exit 1
            fi
            echo "DEBUG: Using package display name: '$PKG_DISPLAY'"
            echo "<details><summary>$PKG_DISPLAY</summary>" >> lists.md
            echo "" >> lists.md
            awk '/^### /{show=1; next} show && /^[*-] /{sub(/^[*-]/,"-"); print $0} /^<\/details>/{show=0}' "block${c}.md" >> lists.md
            echo "" >> lists.md
            echo "</details>" >> lists.md
          done < <(awk 'BEGIN{RS="</details>"; ORS="</details>\0"} /<details>/' "$INPUT_FILE")

          {
            echo "$VERSION_HEADER"
            cat lists.md
          } > release_note.md

          echo "====== Final release note ======"
          cat release_note.md

          # Update the release notes using GitHub CLI
          gh release edit "$TAG_NAME" --notes-file release_note.md

          # CLEANUP: remove all intermediate files
          rm -f pr_body.md details_blocks.txt lists.md block*.md release_note.md
