name: Update Release Notes from PR

on:
  push:
    tags:
      - "v*"

permissions:
  contents: write
  pull-requests: read

jobs:
  update-release-notes:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install gh cli and jq
        run: |
          sudo apt-get update
          sudo apt-get install -y gh jq

      - name: Find latest merged release PR
        id: find_pr
        env:
          GH_TOKEN: ${{ secrets.RELEASE_PLEASE_TOKEN }}
        run: |
          PR_NUMBER=$(gh pr list --state merged --label "autorelease: tagged" --json number,mergedAt,headRefName --jq '[.[] | select(.headRefName | test("^release-please--branches--main"))] | sort_by(.mergedAt) | last.number')
          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT

      - name: Get PR body and format for all packages
        id: get_lists
        env:
          GH_TOKEN: ${{ secrets.RELEASE_PLEASE_TOKEN }}
        run: |
          PR_NUMBER="${{ steps.find_pr.outputs.pr_number }}"
          PR_BODY=$(gh pr view "$PR_NUMBER" --json body -q .body)

          # Extract the first version header with date and link (e.g.: [0.3.3](...) (2025-09-09))
          VERSION_HEADER=$(echo "$PR_BODY" | grep -m1 -E '^\[[0-9]+\.[0-9]+\.[0-9]+\]\(.*\) \([0-9]{4}-[0-9]{2}-[0-9]{2}\)$')

          # If not found, fallback to a generic header
          if [ -z "$VERSION_HEADER" ]; then
            VERSION_HEADER="## Release"
          fi

          # Now, for each package section, extract the package name and its markdown list
          # We'll assume each section starts with the version header, then has bugfix/features sections, etc.
          # and somewhere in each list, the package name appears as bold or in the list item prefix.

          # This awk script grabs each block starting with a version header, and for each:
          # - Extracts the package name from the first bold item (**package_name:** or **package_name**:)
          # - Outputs the block as:
          #   > package_name
          #   (then the block content, minus the version header itself)

          echo "$PR_BODY" | awk '
            BEGIN { block=""; inblock=0; }
            /^\[[0-9]+\.[0-9]+\.[0-9]+\]\(.*\) \([0-9]{4}-[0-9]{2}-[0-9]{2}\)$/ {
              if (inblock && block != "") {
                print block
                block=""
              }
              inblock=1
              next
            }
            inblock { block=block $0 "\n" }
            END { if (inblock && block != "") print block }
          ' | while read -r block; do
              # Find the package name from the first bold entry in a list item
              PKG=$(echo "$block" | grep -m1 -oP '\*\*\K[^*:]+' | sed 's/_/ /g')
              [ -z "$PKG" ] && PKG="unknown package"
              # Output blockquote and the block itself
              echo ""
              echo "> $PKG"
              echo "$block" | sed '/^$/d'  # remove blank line at top
              echo ""
            done > lists.md

          # Compose the final release note file
          {
            echo "$VERSION_HEADER"
            echo "---"
            cat lists.md
          } > release_note.md

          # Print for debug
          echo "====== Final release note ======"
          cat release_note.md

          # Output for next step
          echo "release_note<<EOF" >> $GITHUB_OUTPUT
          cat release_note.md >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Update release notes for tag
        env:
          GH_TOKEN: ${{ secrets.RELEASE_PLEASE_TOKEN }}
        run: |
          gh release edit "${GITHUB_REF#refs/tags/}" --notes "${{ steps.get_lists.outputs.release_note }}"
